
import * as _pi from "pareto-core-interface"

import * as i_out from "./data/unresolved"

import * as i_in from "./data/resolved"

export namespace Text_Type_ {
    
    export type I = i_in.Text_Type
    
    export type O = i_out.Text_Type
    
    export namespace P {
        
    }
    
}

export type Text_Type_ = (
    $$_: Text_Type_.I,
) => Text_Type_.O

export namespace Number_Type_ {
    
    export type I = i_in.Number_Type
    
    export type O = i_out.Number_Type
    
    export namespace P {
        
    }
    
}

export type Number_Type_ = (
    $$_: Number_Type_.I,
) => Number_Type_.O

export namespace Globals_ {
    
    export type I = i_in.Globals
    
    export type O = i_out.Globals
    
    export namespace P {
        
    }
    
}

export type Globals_ = (
    $$_: Globals_.I,
) => Globals_.O

export namespace Type_Parameters_ {
    
    export type I = i_in.Type_Parameters
    
    export type O = i_out.Type_Parameters
    
    export namespace P {
        
    }
    
}

export type Type_Parameters_ = (
    $$_: Type_Parameters_.I,
) => Type_Parameters_.O

export namespace Type_ {
    
    export type I = i_in.Type
    
    export type O = i_out.Type
    
    export namespace P {
        
    }
    
}

export type Type_ = (
    $$_: Type_.I,
) => Type_.O

export namespace Types_ {
    
    export type I = i_in.Types
    
    export type O = i_out.Types
    
    export namespace P {
        
    }
    
}

export type Types_ = (
    $$_: Types_.I,
) => Types_.O

export namespace Resolve_Logic_ {
    
    export type I = i_in.Resolve_Logic
    
    export type O = i_out.Resolve_Logic
    
    export namespace P {
        
    }
    
}

export type Resolve_Logic_ = (
    $$_: Resolve_Logic_.I,
) => Resolve_Logic_.O

export namespace Schema_ {
    
    export type I = i_in.Schema
    
    export type O = i_out.Schema
    
    export namespace P {
        
    }
    
}

export type Schema_ = (
    $$_: Schema_.I,
) => Schema_.O

export namespace Schema_Tree_ {
    
    export type I = i_in.Schema_Tree
    
    export type O = i_out.Schema_Tree
    
    export namespace P {
        
    }
    
}

export type Schema_Tree_ = (
    $$_: Schema_Tree_.I,
) => Schema_Tree_.O

export namespace Type_Specification_ {
    
    export type I = i_in.Type_Specification
    
    export type O = i_out.Type_Specification
    
    export namespace P {
        
    }
    
}

export type Type_Specification_ = (
    $$_: Type_Specification_.I,
) => Type_Specification_.O

export namespace Schemas_ {
    
    export type I = i_in.Schemas
    
    export type O = i_out.Schemas
    
    export namespace P {
        
    }
    
}

export type Schemas_ = (
    $$_: Schemas_.I,
) => Schemas_.O

export namespace Imports_ {
    
    export type I = i_in.Imports
    
    export type O = i_out.Imports
    
    export namespace P {
        
    }
    
}

export type Imports_ = (
    $$_: Imports_.I,
) => Imports_.O

export namespace Presence_ {
    
    export type I = i_in.Presence
    
    export type O = i_out.Presence
    
    export namespace P {
        
    }
    
}

export type Presence_ = (
    $$_: Presence_.I,
) => Presence_.O

export namespace Dictionary_ {
    
    export type I = i_in.Dictionary
    
    export type O = i_out.Dictionary
    
    export namespace P {
        
    }
    
}

export type Dictionary_ = (
    $$_: Dictionary_.I,
) => Dictionary_.O

export namespace Signatures_ {
    
    export type I = i_in.Signatures
    
    export type O = i_out.Signatures
    
    export namespace P {
        
    }
    
}

export type Signatures_ = (
    $$_: Signatures_.I,
) => Signatures_.O

export namespace Resolvers_ {
    
    export type I = i_in.Resolvers
    
    export type O = i_out.Resolvers
    
    export namespace P {
        
    }
    
}

export type Resolvers_ = (
    $$_: Resolvers_.I,
) => Resolvers_.O

export namespace Group_ {
    
    export type I = i_in.Group
    
    export type O = i_out.Group
    
    export namespace P {
        
    }
    
}

export type Group_ = (
    $$_: Group_.I,
) => Group_.O

export namespace Type_Node_ {
    
    export type I = i_in.Type_Node
    
    export type O = i_out.Type_Node
    
    export namespace P {
        
    }
    
}

export type Type_Node_ = (
    $$_: Type_Node_.I,
) => Type_Node_.O

export namespace Type_Reference_ {
    
    export type I = i_in.Type_Reference
    
    export type O = i_out.Type_Reference
    
    export namespace P {
        
    }
    
}

export type Type_Reference_ = (
    $$_: Type_Reference_.I,
) => Type_Reference_.O

export namespace Type_Node_Reference_ {
    
    export type I = i_in.Type_Node_Reference
    
    export type O = i_out.Type_Node_Reference
    
    export namespace P {
        
    }
    
}

export type Type_Node_Reference_ = (
    $$_: Type_Node_Reference_.I,
) => Type_Node_Reference_.O

export namespace Signature_Parameters_ {
    
    export type I = i_in.Signature_Parameters
    
    export type O = i_out.Signature_Parameters
    
    export namespace P {
        
    }
    
}

export type Signature_Parameters_ = (
    $$_: Signature_Parameters_.I,
) => Signature_Parameters_.O

export namespace Signature_ {
    
    export type I = i_in.Signature
    
    export type O = i_out.Signature
    
    export namespace P {
        
    }
    
}

export type Signature_ = (
    $$_: Signature_.I,
) => Signature_.O

export namespace Relative_Value_Selection_ {
    
    export type I = i_in.Relative_Value_Selection
    
    export type O = i_out.Relative_Value_Selection
    
    export namespace P {
        
    }
    
}

export type Relative_Value_Selection_ = (
    $$_: Relative_Value_Selection_.I,
) => Relative_Value_Selection_.O

export namespace Lookup_Selection_ {
    
    export type I = i_in.Lookup_Selection
    
    export type O = i_out.Lookup_Selection
    
    export namespace P {
        
    }
    
}

export type Lookup_Selection_ = (
    $$_: Lookup_Selection_.I,
) => Lookup_Selection_.O

export namespace Constraint_ {
    
    export type I = i_in.Constraint
    
    export type O = i_out.Constraint
    
    export namespace P {
        
    }
    
}

export type Constraint_ = (
    $$_: Constraint_.I,
) => Constraint_.O

export namespace Option_Constraints_ {
    
    export type I = i_in.Option_Constraints
    
    export type O = i_out.Option_Constraints
    
    export namespace P {
        
    }
    
}

export type Option_Constraints_ = (
    $$_: Option_Constraints_.I,
) => Option_Constraints_.O

export namespace Property_Constraints_ {
    
    export type I = i_in.Property_Constraints
    
    export type O = i_out.Property_Constraints
    
    export namespace P {
        
    }
    
}

export type Property_Constraints_ = (
    $$_: Property_Constraints_.I,
) => Property_Constraints_.O

export namespace Reference_To_Property_Constraint_ {
    
    export type I = i_in.Reference_To_Property_Constraint
    
    export type O = i_out.Reference_To_Property_Constraint
    
    export namespace P {
        
    }
    
}

export type Reference_To_Property_Constraint_ = (
    $$_: Reference_To_Property_Constraint_.I,
) => Reference_To_Property_Constraint_.O

export namespace Property_Constraint_ {
    
    export type I = i_in.Property_Constraint
    
    export type O = i_out.Property_Constraint
    
    export namespace P {
        
    }
    
}

export type Property_Constraint_ = (
    $$_: Property_Constraint_.I,
) => Property_Constraint_.O

export namespace Optional_Value_Initialization_ {
    
    export type I = i_in.Optional_Value_Initialization
    
    export type O = i_out.Optional_Value_Initialization
    
    export namespace P {
        
    }
    
}

export type Optional_Value_Initialization_ = (
    $$_: Optional_Value_Initialization_.I,
) => Optional_Value_Initialization_.O

export namespace Node_Resolver_Group_ {
    
    export type I = i_in.Node_Resolver_Group
    
    export type O = i_out.Node_Resolver_Group
    
    export namespace P {
        
    }
    
}

export type Node_Resolver_Group_ = (
    $$_: Node_Resolver_Group_.I,
) => Node_Resolver_Group_.O

export namespace Node_Resolver_List_Result_ {
    
    export type I = i_in.Node_Resolver_List_Result
    
    export type O = i_out.Node_Resolver_List_Result
    
    export namespace P {
        
    }
    
}

export type Node_Resolver_List_Result_ = (
    $$_: Node_Resolver_List_Result_.I,
) => Node_Resolver_List_Result_.O

export namespace Benchmark_ {
    
    export type I = i_in.Benchmark
    
    export type O = i_out.Benchmark
    
    export namespace P {
        
    }
    
}

export type Benchmark_ = (
    $$_: Benchmark_.I,
) => Benchmark_.O

export namespace Node_Resolver_ {
    
    export type I = i_in.Node_Resolver
    
    export type O = i_out.Node_Resolver
    
    export namespace P {
        
    }
    
}

export type Node_Resolver_ = (
    $$_: Node_Resolver_.I,
) => Node_Resolver_.O

export namespace Guaranteed_Value_Selection_ {
    
    export type I = i_in.Guaranteed_Value_Selection
    
    export type O = i_out.Guaranteed_Value_Selection
    
    export namespace P {
        
    }
    
}

export type Guaranteed_Value_Selection_ = (
    $$_: Guaranteed_Value_Selection_.I,
) => Guaranteed_Value_Selection_.O

export namespace Possible_Value_Selection_ {
    
    export type I = i_in.Possible_Value_Selection
    
    export type O = i_out.Possible_Value_Selection
    
    export namespace P {
        
    }
    
}

export type Possible_Value_Selection_ = (
    $$_: Possible_Value_Selection_.I,
) => Possible_Value_Selection_.O

export { 
    Text_Type_ as Text_Type, 
    Number_Type_ as Number_Type, 
    Globals_ as Globals, 
    Type_Parameters_ as Type_Parameters, 
    Type_ as Type, 
    Types_ as Types, 
    Resolve_Logic_ as Resolve_Logic, 
    Schema_ as Schema, 
    Schema_Tree_ as Schema_Tree, 
    Type_Specification_ as Type_Specification, 
    Schemas_ as Schemas, 
    Imports_ as Imports, 
    Presence_ as Presence, 
    Dictionary_ as Dictionary, 
    Signatures_ as Signatures, 
    Resolvers_ as Resolvers, 
    Group_ as Group, 
    Type_Node_ as Type_Node, 
    Type_Reference_ as Type_Reference, 
    Type_Node_Reference_ as Type_Node_Reference, 
    Signature_Parameters_ as Signature_Parameters, 
    Signature_ as Signature, 
    Relative_Value_Selection_ as Relative_Value_Selection, 
    Lookup_Selection_ as Lookup_Selection, 
    Constraint_ as Constraint, 
    Option_Constraints_ as Option_Constraints, 
    Property_Constraints_ as Property_Constraints, 
    Reference_To_Property_Constraint_ as Reference_To_Property_Constraint, 
    Property_Constraint_ as Property_Constraint, 
    Optional_Value_Initialization_ as Optional_Value_Initialization, 
    Node_Resolver_Group_ as Node_Resolver_Group, 
    Node_Resolver_List_Result_ as Node_Resolver_List_Result, 
    Benchmark_ as Benchmark, 
    Node_Resolver_ as Node_Resolver, 
    Guaranteed_Value_Selection_ as Guaranteed_Value_Selection, 
    Possible_Value_Selection_ as Possible_Value_Selection, 
}
